#!/usr/bin/env python3
# -!- encoding:utf8 -!-
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#     file: exploit
#     date: 2018-03-04
#   author: paul.dautry
#  purpose:
#
# Once you've analyzed the source code you know that you have to solve this
# system:
#
# find
# (
#     u00, u01, u02, u03,
#     u04, u05, u06, u07,
#     u08, u09, u10, u11,
#     u12, u13, u14, u15,
#     u16, u17, u18, u19,
#     u20, u21, u22, u23,
#     u24, u25, u26, u27,
#     u28, u29, u30, u31,
#     u32, u33, u34, u35,
#     u36, u37, u38, u39,
#     u40, u41, u42, u43,
#     u44, u45, u46, u47,
#     u48, u49, u50, u51,
#     u52, u53, u54, u55,
#     u56, u57, u58, u59,
#     u60, u61, u62, u63
# )
#
# with the constraint: uxx in [0,255]
#
# and given result:
#
# #define EO_RESULT \
# { \
#     ft0,ft1,ft2,ft3, /* FT */ \
#     fs0,fs1,fs2,fs3, /* FS */ \
#     ts0,ts1,ts2,ts3, /* TS */ \
# }
#
# and the following system generated using the algorithm (appendice A.)
#
# ft0 = ((f00 + f04 + f08 + f12) + (t00 + t04 + t08 + t12)) % 256
# ft1 = ((f01 + f05 + f09 + f13) + (t01 + t05 + t09 + t13)) % 256
# ft2 = ((f02 + f06 + f10 + f14) + (t02 + t06 + t10 + t14)) % 256
# ft3 = ((f03 + f07 + f11 + f15) + (t03 + t07 + t11 + t15)) % 256
#
# fs0 = ((f00 + f01 + f02 + f03) + (s00 + s01 + s02 + s03)) % 256
# fs1 = ((f04 + f05 + f06 + f07) + (s04 + s05 + s06 + s07)) % 256
# fs2 = ((f08 + f09 + f10 + f11) + (s08 + s09 + s10 + s11)) % 256
# fs3 = ((f12 + f13 + f14 + f15) + (s12 + s13 + s14 + s15)) % 256
#
# ts0 = ((t00 + t01 + t02 + t03) + (s00 + s04 + s08 + s12)) % 256
# ts1 = ((t04 + t05 + t06 + t07) + (s01 + s05 + s09 + s13)) % 256
# ts2 = ((t08 + t09 + t10 + t11) + (s02 + s06 + s10 + s14)) % 256
# ts3 = ((t12 + t13 + t14 + t15) + (s03 + s07 + s11 + s15)) % 256
#
# f00 = (u00 + u16 + u32 + u48) % 256
# f01 = (u01 + u17 + u33 + u49) % 256
# f02 = (u02 + u18 + u34 + u50) % 256
# f03 = (u03 + u19 + u35 + u51) % 256
# f04 = (u04 + u20 + u36 + u52) % 256
# f05 = (u05 + u21 + u37 + u53) % 256
# f06 = (u06 + u22 + u38 + u54) % 256
# f07 = (u07 + u23 + u39 + u55) % 256
# f08 = (u08 + u24 + u40 + u56) % 256
# f09 = (u09 + u25 + u41 + u57) % 256
# f10 = (u10 + u26 + u42 + u58) % 256
# f11 = (u11 + u27 + u43 + u59) % 256
# f12 = (u12 + u28 + u44 + u60) % 256
# f13 = (u13 + u29 + u45 + u61) % 256
# f14 = (u14 + u30 + u46 + u62) % 256
# f15 = (u15 + u31 + u47 + u63) % 256
#
# t00 = (u00 + u04 + u08 + u12) % 256
# t01 = (u01 + u05 + u09 + u13) % 256
# t02 = (u02 + u06 + u10 + u14) % 256
# t03 = (u03 + u07 + u11 + u15) % 256
# t04 = (u16 + u20 + u24 + u28) % 256
# t05 = (u17 + u21 + u25 + u29) % 256
# t06 = (u18 + u22 + u26 + u30) % 256
# t07 = (u19 + u23 + u27 + u31) % 256
# t08 = (u32 + u36 + u40 + u44) % 256
# t09 = (u33 + u37 + u41 + u45) % 256
# t10 = (u34 + u38 + u42 + u46) % 256
# t11 = (u35 + u39 + u43 + u47) % 256
# t12 = (u48 + u52 + u56 + u60) % 256
# t13 = (u49 + u53 + u57 + u61) % 256
# t14 = (u50 + u54 + u58 + u62) % 256
# t15 = (u51 + u55 + u59 + u63) % 256
#
# s00 = (u00 + u01 + u02 + u03) % 256
# s01 = (u16 + u17 + u18 + u19) % 256
# s02 = (u32 + u33 + u34 + u35) % 256
# s03 = (u48 + u49 + u50 + u51) % 256
# s04 = (u04 + u05 + u06 + u07) % 256
# s05 = (u20 + u21 + u22 + u23) % 256
# s06 = (u36 + u37 + u38 + u39) % 256
# s07 = (u52 + u53 + u54 + u55) % 256
# s08 = (u08 + u09 + u10 + u11) % 256
# s09 = (u24 + u25 + u26 + u27) % 256
# s10 = (u40 + u41 + u42 + u43) % 256
# s11 = (u56 + u57 + u58 + u59) % 256
# s12 = (u12 + u13 + u14 + u15) % 256
# s13 = (u28 + u29 + u30 + u31) % 256
# s14 = (u44 + u45 + u46 + u47) % 256
# s15 = (u60 + u61 + u62 + u63) % 256
#
# See if Z3 can solve this problem.
#
# Appendice A - Equation system generation algorithm
# -----------------------------------------------------------------------------
# #!/usr/bin/env python3
# # -!- encoding:utf8 -!-
# EO_SZ=4
# EO_FACE_SZ=EO_SZ*EO_SZ
#
# def print_faces():
#     print('face F:')
#     for i in range(0, EO_FACE_SZ):
#         for j in range(0, EO_SZ):
#             print('f%02d += u%02d' % (i, i+j*EO_FACE_SZ))
#     print('face S:')
#     for i in range(0, EO_FACE_SZ):
#         for j in range(0, EO_SZ):
#             print('s%02d += u%02d' % (i, j+(i%EO_SZ)*EO_FACE_SZ+(i//EO_SZ)*EO_SZ))
#     print('face T:')
#     for i in range(0, EO_FACE_SZ):
#         for j in range(0, EO_SZ):
#             print('t%02d += u%02d' % (i, i+j*EO_SZ+(i//EO_SZ)*(EO_FACE_SZ-EO_SZ)))
#
# def print_vectors():
#     print('FT vector:')
#     for i in range(0, EO_SZ):
#         for j in range(0, EO_SZ):
#             idxFT = i + j * EO_SZ
#             idxFS = i * EO_SZ + j
#             print('ft%02d += f%02d + t%02d' % (i, idxFT, idxFT))
#     print('FS vector:')
#     for i in range(0, EO_SZ):
#         for j in range(0, EO_SZ):
#             idxFT = i + j * EO_SZ
#             idxFS = i * EO_SZ + j
#             print('fs%02d += f%02d + s%02d' % (i, idxFS, idxFS))
#     print('TS vector:')
#     for i in range(0, EO_SZ):
#         for j in range(0, EO_SZ):
#             idxFT = i + j * EO_SZ
#             idxFS = i * EO_SZ + j
#             print('ts%02d += t%02d + s%02d' % (i, idxFT, idxFS))
#
# def main():
#     print_faces()
#     print_vectors()
#
# main()
#
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# =============================================================================
#  IMPORTS
# =============================================================================
import os
import requests
import os.path as path
from ruamel import yaml
from argparse import ArgumentParser
# =============================================================================
#  CLASSES
# =============================================================================
##
## @brief      Class for exploit.
##
class Exploit(object):
    ##
    ## @brief      Constructs the object.
    ##
    ## @param      url, the target url
    ##
    def __init__(self, url):
        super(Exploit, self).__init__()
        self.url = url
    ##
    ## @brief      { function_description }
    ##
    def run(self, key):
        print("[exploit](GCorp - Stage 4)> exploit running...")
        resp = requests.get(self.url, timeout=1)
        print(resp.content.decode())
        print("[exploit](GCorp - Stage 4)> sending the right key...")
        resp = requests.post(self.url, data=key, timeout=1)
        content = resp.content.decode()
        print(content)
        return ('INSA{' in content)
# =============================================================================
#  SCRIPT
# =============================================================================
if __name__ == '__main__':
    current_dir = path.dirname(path.abspath(__file__))

    with open(path.join(current_dir, '..', '.mkctf.yml')) as f:
        conf = yaml.safe_load(f)

    parameters = conf['parameters']

    with open(path.join(current_dir, parameters['exploit']['key']), 'rb') as f:
        key = f.read()

    p = ArgumentParser(add_help=True, description="GCorp - Stage 4 exploit")
    p.add_argument('--url', default=parameters['exploit']['url'],
                   help="Target url")
    args = p.parse_args()

    e = Exploit(args.url)
    exit(0 if e.run(key) else 1)
